# 1. 그래프를 코드로 표현
# - 인접 행렬
# - 인접 리스트

# - V x V 배열을 활용해서 표현
# - 갈 수 없다면 0, 있다면 1(가중치) 을 저장

    # - 장점
    # - 노드간의 연결 정보를 한 방에 확인 가능
    # - 간선이 많을수록 유리

    # - 단점
    # - 노드 수가 커지면 메모리가 낭비된다.
    # - 연결이 안된 것도 저장

# 특징 : 양방향 그래프는
#       중앙 우하단 대각선 기준으로 대칭됨


'''

graph = [
     [0, 1, 0, 1, 0],
    [1, 0, 1, 0, 1],
    [0, 1, 0, 0, 0],
    [1, 0, 0, 0, 1],
   [0, 1, 0, 1, 0],
]

'''



# -  인접 리스트
# - V 개의 노드가 갈 수 있는 정보만 저장

# - 장점
# - 메모리 사용량이 적다
# - 탐색할때 갈 수 있는 곳만 확인하기 때문에
# - 시간적으로 효율

# - 단점
# - 연결 여부를 확인하는데 시간이 걸린다.


'''
graph = [
    [1, 3],
    [0, 2, 4],
    [1],
    [0, 4],
    [1, 3],
]

'''
'''
# 인접 행렬 DFS

graph = [
    [0, 1, 0, 1, 0],
    [1, 0, 1, 0, 1],
    [0, 1, 0, 0, 0],
    [1, 0, 0, 0,  1],
    [0, 1, 0, 1, 0],
]

visited = [0] * 5

# now : 시작점
def dfs(now=0):
    # 기저 조건
    # 지금 문제에선 없다
    
    # 다음 재귀 함수 호출 전
    visited[now] = 1
    print(now, end=' ')
    # DFS의 방문순서를 보여준다.


    # 다음 재귀 호출
    # dfs: 현재 노드에서 다른 노드들을 확인
    for i in range(5):
        # 갈 수 없다면
        if graph[now][i] == 0:
            continue
        # 이미 방문했다면 pass

        if visited[i]:
            continue

        dfs(i)

    # 돌아왔을 때 작업

dfs()


'''




graph = [
    [0, 1, 0, 1, 0],
    [1, 0, 1, 0, 1],
    [0, 1, 0, 0, 0],
    [1, 0, 0, 0,  1],
    [0, 1, 0, 1, 0],
]


### bfs
def bfs(start):
    visited = [0] * 5

    queue = [start]
    visited[start] = 1

    while queue:
        now = queue.pop(0)
        print(now, end=' ')

        # 갈 수 있는 곳을 체크
        for to in range(5):
            if graph[now][to] == 0:
                continue

            if visited[to]:
                continue

            visited[to] = 1
            queue.append(to)


bfs(0)